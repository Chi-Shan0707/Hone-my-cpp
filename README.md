## 定义屏蔽
```
int a,b;
a=2;
if()
{
    int a=1;
    //按照里头的a进行运算
}
```

## 函数默认参数
```
int func(int a=1,int b=2,int c=3)
{
    return a*b*c;
}
func();//6
func(2);//2*2*3
func(2,3);//2*3*3
```

## extern

## static
```
static int a=1;
static void func(){};//都只能本文件用 
```

## 动态存储和静态存储
<p>
形参自动存储
人工via指令 自由存储
<p>

<p>
全局变量占用静态控件
<p>


**自动对象** ：函数或复合语句中的对象（包含形参）称为自动对象，一般是自动存储

形参：函数里的参数<br>
实参：传给函数的<br>

```
auto 类型 变量名[=初值];
auto可省略
```

**寄存器变量**:将局部变量放在cpu寄存器上，存储空间有限，但访问更快
```
register int a;
```

**局部静态变量**: 在局部变量面前+static<br>
存储空间不会被释放，可以保留值
```
int fun()
{
    static int a=1;
    ++a;
    return a;
}
int main()
{
    int i,c;
    for(i=1;i<=10;++i)c=fun();
    cout<<c;//10
}
```

## 数组作为参数
返回类型 func(类型 数组名[常量表达式])

*数组的名字相当于数组的首地址*<br>
数组是*连续存储的一段空间*,只需知道第一个字节的地址
<p>
原先函数实参将值传递给形参，内存开辟一个空间用来拷贝实参的值，但是数组就是根据这个值去找到那一串数，所以和传整数不会被修改不同，传输组会被修改
<p>

## 抽象 封装 继承与派生

面向对象程序设计一般将数据隐蔽器来，外部不能直接访问，而是把成员函数作为对外界的接口，通过成员函数访问数据。即数据成员是属性，成员数据是方法，通过方法存取属性

```
class Something
{
    int func(int a,int b);
};
int Something::func(int a,int b)
{

}
```
未用class定义是实体的时候，不会占据存储空间 


派生和继承可以用protected
private最私产

## 初始化列表？const

## 析构函数
<p>何时调用析构函数:<p>

- (1) 对象在程序运行超出其作用域时自动撤销，撤销时自动调用该对象的析构函数。如函数中的非静态局部对象。<br>
- (2) 如果用new运算动态地建立了一个对象，那么用delete运算释放该对象时，调用该对象的析构函数。<br>

<p>
与复制构造函数不同，编译器总是会为类生成一个析构函数，称为合成析构函数(synthesized destructor)<br>
合成析构函数按对象创建时的逆序撤销每个非静态成员，即它是按成员在类中声明次序的逆序撤销成员的。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象<br>
需要注意，合成析构函数并不删除指针成员所指向的对象，它需要程序员显式编写析构函数去处理。<br>
<p>